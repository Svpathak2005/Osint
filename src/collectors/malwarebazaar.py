"""
MalwareBazaar collector (abuse.ch MalwareBazaar API)

Usage:
  python src/collectors/malwarebazaar.py            # fetches recent samples (default)
  python src/collectors/malwarebazaar.py recent 50  # fetch latest 50 entries
  python src/collectors/malwarebazaar.py sha256 <sha256>  # fetch metadata for a single sample

Notes:
 - No API key required for the public MalwareBazaar API.
 - Endpoint: https://mb-api.abuse.ch/api/v1/
 - This writes JSONL lines to data/raw/malwarebazaar/YYYY-MM-DD.jsonl
"""

from dotenv import load_dotenv
import os
import sys
import json
import time
import datetime
from pathlib import Path
import httpx

# locate project root and load .env (safe even if no key required)
PROJECT_ROOT = Path(__file__).resolve().parents[2]
DOTENV_PATH = PROJECT_ROOT / ".env"
# load .env if present (harmless if missing)
load_dotenv(DOTENV_PATH)

RAW_DIR = PROJECT_ROOT / "data" / "raw" / "malwarebazaar"
RAW_DIR.mkdir(parents=True, exist_ok=True)
OUT_FILE = RAW_DIR / f"{datetime.date.today()}.jsonl"

MB_URL = "https://mb-api.abuse.ch/api/v1/"

TIMEOUT = 20.0
MAX_RETRIES = 3
INITIAL_BACKOFF = 1.0

def _sleep_backoff(backoff):
    time.sleep(backoff + (0.1 * (time.time() % 1)))

def fetch_recent(limit=100):
    """
    Fetch recent samples.
    POST { 'query': 'get_recent', 'limit': <n> }
    """
    data = {"query": "get_recent", "limit": str(limit)}
    backoff = INITIAL_BACKOFF
    with httpx.Client(timeout=TIMEOUT) as client:
        for attempt in range(1, MAX_RETRIES + 1):
            try:
                resp = client.post(MB_URL, data=data)
                if resp.status_code == 429:
                    ra = resp.headers.get("Retry-After")
                    wait = float(ra) if ra and ra.isdigit() else backoff
                    print(f"[warn] MalwareBazaar 429. wait {wait}s")
                    _sleep_backoff(wait)
                    backoff *= 2
                    continue
                resp.raise_for_status()
                return resp.json()
            except httpx.RequestError as exc:
                print(f"[warn] Network error (recent) attempt {attempt}: {exc}")
                if attempt < MAX_RETRIES:
                    _sleep_backoff(backoff); backoff *= 2
                    continue
                raise
            except httpx.HTTPStatusError as exc:
                code = exc.response.status_code
                print(f"[error] HTTP error (recent): {code} - {exc.response.text[:200]}")
                raise
    raise RuntimeError("fetch_recent failed")

def fetch_by_sha256(sha256):
    """
    Fetch metadata for a single sample.
    POST { 'query': 'get_info', 'sha256': '<sha256>' }
    """
    data = {"query": "get_info", "sha256": sha256}
    backoff = INITIAL_BACKOFF
    with httpx.Client(timeout=TIMEOUT) as client:
        for attempt in range(1, MAX_RETRIES + 1):
            try:
                resp = client.post(MB_URL, data=data)
                if resp.status_code == 429:
                    ra = resp.headers.get("Retry-After")
                    wait = float(ra) if ra and ra.isdigit() else backoff
                    print(f"[warn] MalwareBazaar 429. wait {wait}s")
                    _sleep_backoff(wait)
                    backoff *= 2
                    continue
                resp.raise_for_status()
                return resp.json()
            except httpx.RequestError as exc:
                print(f"[warn] Network error (sha256) attempt {attempt}: {exc}")
                if attempt < MAX_RETRIES:
                    _sleep_backoff(backoff); backoff *= 2
                    continue
                raise
            except httpx.HTTPStatusError as exc:
                code = exc.response.status_code
                print(f"[error] HTTP error (sha256): {code} - {exc.response.text[:200]}")
                raise
    raise RuntimeError("fetch_by_sha256 failed")

def main():
    args = sys.argv[1:]
    results = []
    if not args or args[0].lower() == "recent":
        # default recent; optional second arg = limit
        limit = 100
        if len(args) >= 2:
            try:
                limit = int(args[1])
            except ValueError:
                print("[warn] invalid limit, using default 100")
        print(f"[info] Fetching MalwareBazaar recent (limit={limit})...")
        try:
            payload = fetch_recent(limit=limit)
            # payload typically contains keys like 'data' with list of samples
            results.append({
                "indicator": "recent",
                "type": "metadata-list",
                "source": "malwarebazaar",
                "fetched_at": datetime.datetime.now(datetime.UTC).isoformat(),
                "data": payload
            })
        except Exception as e:
            print(f"[error] fetch_recent failed: {e}")

    elif args[0].lower() == "sha256" and len(args) >= 2:
        sha = args[1].strip()
        print(f"[info] Fetching MalwareBazaar info for {sha} ...")
        try:
            payload = fetch_by_sha256(sha)
            results.append({
                "indicator": sha,
                "type": "file",
                "source": "malwarebazaar",
                "fetched_at": datetime.datetime.now(datetime.UTC).isoformat(),
                "data": payload
            })
        except Exception as e:
            print(f"[error] fetch_by_sha256 failed: {e}")
    else:
        # treat each arg as either sha256 or url; attempt sha256 calls
        for token in args:
            t = token.strip()
            print(f"[info] Fetching MalwareBazaar info for {t} ...")
            try:
                payload = fetch_by_sha256(t)
                results.append({
                    "indicator": t,
                    "type": "file",
                    "source": "malwarebazaar",
                    "fetched_at": datetime.datetime.now(datetime.UTC).isoformat(),
                    "data": payload
                })
                time.sleep(1)
            except Exception as e:
                print(f"[error] fetch_by_sha256 failed for {t}: {e}")

    # write JSONL (append)
    if results:
        with open(OUT_FILE, "a", encoding="utf-8") as f:
            for item in results:
                f.write(json.dumps(item, ensure_ascii=False) + "\n")
        print(f"[ok] Wrote {len(results)} items to {OUT_FILE}")
    else:
        print("[info] No results to write.")

if __name__ == "__main__":
    main()
